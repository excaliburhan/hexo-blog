<!DOCTYPE html>
<html lang="zh-CN">


<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>
    你应该知道的浏览器缓存知识 | 韩小平的胡言乱语地
  </title>
  <meta name="description" content="">
  
  <meta name="keywords" content="
  
  ">
  
  <meta name="author" content="excalirbuhan">

  <meta http-equiv="Cache-Control" content="no-transform"/>
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="theme-color" content="#1e2327">
  <link rel="apple-touch-icon" href="https://github.githubassets.com/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://github.githubassets.com/apple-touch-icon-180x180.png">

  <link rel="icon" type="image/x-icon" href="https://github.githubassets.com/favicon.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet"
        href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  

  

  <script src="//cdnjs.cloudflare.com/ajax/libs/vue/1.0.25-csp/vue.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.11.2/moment.min.js"></script>
<meta name="generator" content="Hexo 7.3.0"></head>

<body id="replica-app">

<nav class="navbar-wrapper">
  <div class="navbar">
    <div class="container clearfix">
      <a href="/" class="navbar-logo"><i class="fa fa-github"></i></a>

      <div class="navbar-search float-left desktop-only">
        <div class="navbar-search-form">
          <label for="gsc-i-id1">This website</label>
          <div id="google-search">
            <gcse:search></gcse:search>
          </div>
        </div>
      </div>

      <ul class="navbar-nav float-left">
        
        <li><a href="/archives">Archives</a></li>
        
        
        <li><a href="/categories">Categories</a></li>
        
        
        <li><a href="/tags">Tags</a></li>
        
        
        <li class="desktop-only"><a href="/atom.xml" target="_blank">RSS</a></li>
        
      </ul>

      <ul class="navbar-nav user-nav float-right desktop-only">
        <li class="user-nav-notification">
          <a><span class="user-nav-unread"></span><i class="fa fa-bell"></i></a>
        </li>
        <li>
          <a><i class="fa fa-plus"></i> <i class="fa fa-caret-down"></i></a>
        </li>
        <li class="user-nav-logo">
          <a><img src="https://avatars.githubusercontent.com/u/4994398"> <i class="fa fa-caret-down"></i></i></a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<div class="main-container">
  <header class="header-wrapper desktop-only">
  <div class="container header-site-detail">
    <ul class="header-toolbar">
      <li class="clearfix">
        <a href="/archives" class="header-toolbar-left"><i
                  class="fa fa-file-text"></i> Posts </a>
        <a href="/archives"
           class="header-toolbar-right"> 20 </a>
      </li>
      <li>
        <a href="/tags" class="header-toolbar-left"><i
                  class="fa fa-tags"></i> Tags </a>
        <a href="/tags"
           class="header-toolbar-right"> 0 </a>
      </li>
      <li>
        <a href="/categories" class="header-toolbar-left"><i
                  class="fa fa-folder-open"></i> Categories </a>
        <a href="/categories"
           class="header-toolbar-right"> 13 </a>
      </li>
    </ul>
    <h2 class="header-title">
      <i class="fa fa-book text-muted"></i>
      <a href="/">韩小平的胡言乱语地</a>
      
      
    </h2>
  </div>

  <div class="container">
    <div class="header-tab-wrapper clearfix">
      <span class="header-tab header-tab-selected"><i class="fa fa-thumbs-o-up"></i> Like</span>
      <span class="header-tab"><i class="fa fa-share-alt"></i> Share</span>
      <span class="header-tab"><i class="fa fa-comments-o"></i> Discussion</span>
      <span class="header-tab"><i class="fa fa-bookmark-o"></i> Bookmark </span>
      <span class="header-tab"><i class="fa fa-smile-o"></i> Smile <i class="fa fa-caret-down"></i></span>
    </div>
  </div>
</header>


<div class="post-container container">
  <h3>
    <i class="fa fa-user-o"></i>
    excalirbuhan

    <span class="post-date float-right" title="{{moment(1490544000000).format('MMM DD, YYYY, h:mm:ss A')}}">
      
          <i class="fa fa-pencil-square-o"></i>
      
      {{moment(1490544000000).fromNow()}}
    </span>
  </h3>

  <article class="post-content">
    <h1>你应该知道的浏览器缓存知识</h1>
    <h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>浏览器缓存作为性能优化的重要一环，对于前端而言，重要性不言而喻。之前被人问起浏览器缓存的知识，感觉自己有点一知半解，所以这次好好整理总结了一下。</p>
<span id="more"></span>

<h2 id="1-浏览器缓存分类"><a href="#1-浏览器缓存分类" class="headerlink" title="1. 浏览器缓存分类"></a>1. 浏览器缓存分类</h2><p>目前主流的浏览器缓存分为两类，强缓存和协商缓存，它们的匹配流程如下：</p>
<p>（1）浏览器发送请求前，根据请求头的 expires 和 cache-control 判断是否命中强缓存策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。</p>
<p>（2）没有命中强缓存规则，浏览器会发送请求，根据请求头的 last-modified 和 etag 判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。</p>
<p>（3）如果前两步都没有命中，则直接从服务端获取资源。</p>
<h2 id="2-强缓存"><a href="#2-强缓存" class="headerlink" title="2. 强缓存"></a>2. 强缓存</h2><h3 id="2-1-强缓存原理"><a href="#2-1-强缓存原理" class="headerlink" title="2.1 强缓存原理"></a>2.1 强缓存原理</h3><p>强缓存需要服务端设置 expires 和 cache-control。</p>
<p>nginx 代码参考，设置了一年的缓存时间：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ .*\.(ico|svg|ttf|eot|woff)(.*)</span> &#123;</span><br><span class="line">  <span class="attribute">proxy_cache</span>               pnc;</span><br><span class="line">  <span class="attribute">proxy_cache_valid</span>         <span class="number">200</span> <span class="number">304</span> <span class="number">1y</span>;</span><br><span class="line">  <span class="attribute">proxy_cache_valid</span>         any <span class="number">1m</span>;</span><br><span class="line">  <span class="attribute">proxy_cache_lock</span>          <span class="literal">on</span>;</span><br><span class="line">  <span class="attribute">proxy_cache_lock_timeout</span>  <span class="number">5s</span>;</span><br><span class="line">  <span class="attribute">proxy_cache_use_stale</span>     updating <span class="literal">error</span> timeout invalid_header http_500 http_502;</span><br><span class="line">  <span class="attribute">expires</span>                   <span class="number">1y</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://static.excaliburhan.com/blog/20170327/UQQrhatzWnpiKcjkBAR-Cwy5.jpeg" alt="alt"></p>
<p>（1）expires：从图可以看出，expires 的值是一个绝对时间，是 http1.0 的功能。如果浏览器的时间没有超过这个 expires 的时间，代表缓存还有效，命中强缓存，直接从缓存读取资源。不过由于存在浏览器和服务端时间可能出现较大误差，所以在之后 http1.1 提出了 cache-control。</p>
<p>（2）cache-control：从图可以看出，cache-control 的值是类似于<code>max-age=31536000</code>这样的，是一个相对时间，31536000 是秒数，正好是一年的时间。当浏览器第一次请求资源的时候，会把 response header 的内容缓存下来。之后的请求会先从缓存检查该 response header，通过第一次请求的 date 和 cache-control 计算出缓存有效时间。如果浏览器的时间没有超过这个缓存有效的时间，代表缓存还有效，命中强缓存，直接从缓存读取资源。</p>
<p>两者可以同时设置，但是优先级 cache-control &gt; expires。</p>
<h3 id="2-2-from-disk-cache-和-from-memory-cache"><a href="#2-2-from-disk-cache-和-from-memory-cache" class="headerlink" title="2.2 from disk cache 和 from memory cache"></a>2.2 from disk cache 和 from memory cache</h3><p>Chrome 在高版本更新了缓存策略（具体哪个我忘了），原来的<code>from cache</code>变成了<code>from disk cache(磁盘缓存)</code>和<code>from memory cache(内存缓存)</code>两类，两者有什么区别呢？</p>
<p>先从官方文档来看下：</p>
<blockquote>
<p>Chrome employs two caches — an on-disk cache and a very fast in-memory cache. The lifetime of an in-memory cache is attached to the lifetime of a render process, which roughly corresponds to a tab. Requests that are answered from the in-memory cache are invisible to the web request API. If a request handler changes its behavior (for example, the behavior according to which requests are blocked), a simple page refresh might not respect this changed behavior. To make sure the behavior change goes through, call handlerBehaviorChanged() to flush the in-memory cache. But don’t do it often; flushing the cache is a very expensive operation. You don’t need to call handlerBehaviorChanged() after registering or unregistering an event listener.</p>
</blockquote>
<p>我的渣六级英语翻一下，大概就是内存缓存是和渲染进程绑定的，大部分情况下于浏览器 Tab 对应。为此我实验了一下：</p>
<p>首次打开 Tab：</p>
<p><img src="https://static.excaliburhan.com/blog/20170327/wHYczt-esCaoSWimZ6JHWVhz.jpeg" alt="alt"></p>
<p>刷新(cmd+r)Tab：</p>
<p><img src="https://static.excaliburhan.com/blog/20170327/BnoONl2XIQoNYvHCbK7O5-fW.jpeg" alt="alt"></p>
<p>可以看到，在命中强缓存的情况下，进程初次渲染会从磁盘读取缓存资源。Chrome 会将部分资源保存到内存中（具体保存的逻辑还不清楚，如果有知道的请告知）。</p>
<p>由于内存缓存是直接从内存中读取的，所以速度更快，从图中可以看出时间是 0ms。而磁盘缓存还需要从磁盘中读取，速度还和磁盘的 I&#x2F;O 有关，时间大概在 2 ～ 10ms，也是相当快的了。</p>
<h3 id="2-3-强缓存作用"><a href="#2-3-强缓存作用" class="headerlink" title="2.3 强缓存作用"></a>2.3 强缓存作用</h3><p>强缓存作为性能优化中缓存方面最有效的手段，能够极大的提升性能。由于强缓存不会向服务端发送请求，对服务端的压力也是大大减小。</p>
<p>对于不太经常变更的资源，可以设置一个超长时间的缓存时间，比如一年。浏览器在首次加载后，都会从缓存中读取。</p>
<p>但是由于不会向服务端发送请求，那么如果资源有更改的时候，怎么让浏览器知道呢？现在常用的解决方法是加一个<code>?v=xxx</code>的后缀，在更新静态资源版本的时候，更新这个 v 的值，这样相当于向服务端发起一个新的请求，从而达到更新静态资源的目的。</p>
<h2 id="3-协商缓存"><a href="#3-协商缓存" class="headerlink" title="3. 协商缓存"></a>3. 协商缓存</h2><h3 id="3-1-协商缓存原理"><a href="#3-1-协商缓存原理" class="headerlink" title="3.1 协商缓存原理"></a>3.1 协商缓存原理</h3><p>在强缓存没有命中的时候，就是协商缓存发挥的地盘了。协商缓存会根据[last-modified&#x2F;if-modified-since]或者[etag&#x2F;if-none-match]来进行判断缓存是否过期。</p>
<p>nginx 代码参考：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ .*\.(ico|svg|ttf|eot|woff)(.*)</span> &#123;</span><br><span class="line">  <span class="attribute">proxy_cache</span>               pnc;</span><br><span class="line">  <span class="attribute">proxy_cache_valid</span>         <span class="number">200</span> <span class="number">304</span> <span class="number">1y</span>;</span><br><span class="line">  <span class="attribute">proxy_cache_valid</span>         any <span class="number">1m</span>;</span><br><span class="line">  <span class="attribute">proxy_cache_lock</span>          <span class="literal">on</span>;</span><br><span class="line">  <span class="attribute">proxy_cache_lock_timeout</span>  <span class="number">5s</span>;</span><br><span class="line">  <span class="attribute">proxy_cache_use_stale</span>     updating <span class="literal">error</span> timeout invalid_header http_500 http_502;</span><br><span class="line">  <span class="attribute">etag</span>                                       <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://static.excaliburhan.com/blog/20170327/CrDzh0AaGQw0SJNw714JjHRC.jpeg" alt="alt"></p>
<p>（1）last-modified&#x2F;if-modified-since:<br>浏览器首先发送一个请求，让服务端在 response header 中返回请求的资源上次更新时间，就是<code>last-modified</code>，浏览器会缓存下这个时间。然后浏览器再下次请求中，request header 中带上<code>if-modified-since:[保存的last-modified的值]</code>。根据浏览器发送的修改时间和服务端的修改时间进行比对，一致的话代表资源没有改变，服务端返回正文为空的响应，让浏览器中缓存中读取资源，这就大大减小了请求的消耗。由于 last-modified 依赖的是保存的绝对时间，还是会出现误差的情况：一是保存的时间是以秒为单位的，1 秒内多次修改是无法捕捉到的；二是各机器读取到的时间不一致，就有出现误差的可能性。为了改善这个问题，提出了使用 etag。</p>
<p>（2）etag&#x2F;if-none-match：</p>
<blockquote>
<p>etag 是 http 协议提供的若干机制中的一种 Web 缓存验证机制，并且允许客户端进行缓存协商。生成 etag 常用的方法包括对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。<br>和<code>last-modified</code>一样，浏览器会先发送一个请求得到 etag 的值，然后再下一次请求在 request header 中带上<code>if-none-match:[保存的etag的值]</code>。通过发送的 etag 的值和服务端重新生成的 etag 的值进行比对，如果一致代表资源没有改变，服务端返回正文为空的响应，告诉浏览器从缓存中读取资源。</p>
</blockquote>
<p>etag 能够解决 last-modified 的一些缺点，但是 etag 每次服务端生成都需要进行读写操作，而 last-modified 只需要读取操作，从这方面来看，etag 的消耗是更大的。</p>
<h3 id="3-2-协商缓存作用"><a href="#3-2-协商缓存作用" class="headerlink" title="3.2 协商缓存作用"></a>3.2 协商缓存作用</h3><p>协商缓存是无法减少请求数的开销的，但是可以减少返回的正文大小。一般来说，对于勤改动的 html 文件，使用协商缓存是一种不错的选择。</p>
<h2 id="4-刷新缓存方法"><a href="#4-刷新缓存方法" class="headerlink" title="4. 刷新缓存方法"></a>4. 刷新缓存方法</h2><p>刷新强缓存可以使用<code>?v=xxx</code>的后缀。当然，人工更改版本号的成本比较高，而且难以维护，现在主流的是通过 webpack 等打包工具生成<code>[name].[hash].js</code>之类的文件名，也能刷新强缓存。</p>
<p>刷新协商缓存比较简单，修改文件内容即可。</p>
<p>对于浏览器而言，在 Chrome 中，你可以使用<code>审查元素</code>，高版本也叫<code>检查</code>，将 Network 中的 Disable cache 打勾，使用<code>cmd+r</code>刷新页面即可。当然你也可以使用强制刷新，直接在页面使用<code>cmd+shift+r</code>进行刷新。</p>
<h2 id="5-结尾"><a href="#5-结尾" class="headerlink" title="5. 结尾"></a>5. 结尾</h2><p>以上就是对浏览器缓存的一点拙见，欢迎一起交流。</p>
<p>这篇主要交代了浏览器缓存，下一篇文章内容已经想好了，就是 html5 的离线缓存。</p>

  </article>
</div>


    




</div>

<div class="footer-wrapper container">
  <footer class="footer clearfix">
    <div class="clearfix">
    <a href="https://www.excaliburhan.com" class="footer-logo">
      <i class="fa fa-github"></i>
    </a>
    <ul class="footer-social-link">
      <li>© 2019 excalirbuhan</li>
      <li><a href="https://www.excaliburhan.com">Home</a></li>
      
      <li><a target="_blank" rel="noopener" href="https://github.com/excaliburhan">Github</a></li>
      
    </ul>
    <div class="footer-theme-info">
      Theme <a target="_blank" rel="noopener" href="//github.com/sabrinaluo/hexo-theme-replica">Replica</a>
      by <a target="_blank" rel="noopener" href="//github.com/sabrinaluo">Hiitea</a> ❤ Powered by Hexo
    </div>
    </div>
    
  </footer>
</div>




<script src="/js/main.js"></script>

</body>
</html>
